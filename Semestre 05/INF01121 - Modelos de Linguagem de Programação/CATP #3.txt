CATP #3

Exercícios:

-------------------------------------------------------
1) Dado o código abaixo:
val p1 = (10, 10);
val p2 = (20, 15);
val d = distancia(p1, p2);

Elabore a função "distância" de forma que o código anterior funcione. A função 
recebe duas tuplas (pares ordenados) correspondentes a dois pontos em um espaço 
de coordenadas cartesiano. A função deve retornar a distancia entre eles (um número 
real). 

val p1 = [10.0, 10.0];
val p2 = [20.0, 20.0];
load "Math";
fun distancia p1 p2 = Math.sqrt( Math.pow((hd(p1)-hd(p2)),2.0) + Math.pow((hd(tl(p1))-hd(tl(p2))),2.0) );
fun distancia p1 p2 = Math.sqrt( Math.pow((hd(p1)-hd(p2)),2.0) + Math.pow((last(p1)-last(p2)),2.0) );

distancia p1 p2;
Obs.: Um problema que estava dando é que antes eu usava tl(p1) ao invés de hd(tl(p1)) e dava erro de tipo.
Isso ocorre pois tl() retorna uma lista, mas eu estou trabalhando com reais, logo preciso dar um novo hd().
-------------------------------------------------------

-------------------------------------------------------
2) Elabore a função "pares", que recebe uma lista de números inteiros e retorna uma nova lista contendo somente os números pares da lista passada. Utilize if ... then ... else na construção da função.

fun pares [] = []
|   pares (h::t) = (if (h mod 2) = 0 then (h::[]) else [])@(pares t);
-------------------------------------------------------

-------------------------------------------------------
3. Elabore uma função que receba uma lista e retorne uma outra lista indicando, 
para cada elemento, se ele é positivo (true) ou negativo (false). Números 
negativos, em ML, são precedidos de "~". 
e.g., positivos [1, ~2, 4, 6, ~10] -> [true, false, true, true, false]

OBS: A função deve fazer uso do operador map e de uma função auxiliar de 
avaliação não nomeada. 

fun positivos [] = [] |
    positivos (h::t) = (if h >=0 then true else false)::(positivos t);

ou

fun positivos l = map( fn x => (if x >=0 then true else false) )l;

ou

val positivos = map( fn x => (if x >=0 then true else false) );
-------------------------------------------------------

-------------------------------------------------------
4. Função que recebe um número e testa se ele é primo.

fun primo n x = 
(if (n mod x) = 0
	then (if (n = x) then true else false)
	else (primo n (x+1))
);

fun testprimo n = (primo n 2);
-------------------------------------------------------

-------------------------------------------------------
5. Elabore uma função que ordene listas. 
e.g., ordena [1,4,10,5, 2] -> [1, 2, 4, 5, 10]

fun insert (x,[]) = [x] |
    insert (x,h::t) = if (x <= h) then x::h::t else h::insert(x,t);

fun insertionsort (h::[]) = [h] |
    insertionsort (h::t) = insert(h, insertionsort(t));
-------------------------------------------------------

-------------------------------------------------------
6. Elabore uma função que some os números pares de uma lista.

fun somapar [] = 0 |
    somapar (h::t) = if h mod 2 = 0 then h + somapar(t) else somapar(t);
-------------------------------------------------------