#ifndef INTERFACE_H#define INTERFACE_H#include <stdio.h>#include <stdlib.h>#include <GL/glut.h>#include <opencv/cv.h>#include <opencv/highgui.h>#include "board.h"#include "round.h"#include "minimax.h"//--------------------------------------------------------------------------// Definições//-------------------------------------------------------------------------- //Janelas da GLUT#define MAIN 0#define MAX_WINDOWS 1//Peças e Posições#define	MAX_PIECES 			61#define PIECE_OFFSET 		16 	//largura ou altura da peça divido por 2 #define POSITION_Y_OFFSET 	48#define	POSITION_Y_INI 		67#define POSITION_Y_AJUST 	2#define POSITION_X_OFFSET 	28#define POSITION_X_AJUST 	2#define POSITION_X_INI 		34//Jogadores#define	NUM_PLAYERS		2#define PLAYER_HUMAN	0	//humano será sempre peça preta#define PLAYER_PC		1	//PC será sempre peça branca//Jogo#define GAME_RUNNING	1#define	GAME_END		0//Ordem dos objetos nos vetores de dimensões#define NUM_OBJETOS		3#define	BOARD			2//Funções para teste de coordenadas #define BETWEEN(X, A, B) ((X >= A) && (X <= B))#define IN(X, Y, A, B) ((BETWEEN(X, A - PIECE_OFFSET, A + PIECE_OFFSET)) && \						(BETWEEN(Y, B - PIECE_OFFSET, B + PIECE_OFFSET)))//--------------------------------------------------------------------------// Estruturas de dados//--------------------------------------------------------------------------typedef struct Par {	int x;	int y;	struct Par *nextPar;} Par;//--------------------------------------------------------------------------// Variáveis Globais//--------------------------------------------------------------------------//manipulador de janelasint windows[MAX_WINDOWS];//dimensões da imagem do tabuleiroint width[NUM_OBJETOS], height[NUM_OBJETOS], channel[NUM_OBJETOS];//ponteiro para a matriz de pixels da imagem do tabuleirounsigned char *boardPixels;unsigned char *piecePixels[NUM_PLAYERS];//estrutura da highgui para manipular a imagem do tabuleiroIplImage *boardImg;IplImage *pieceImg[NUM_PLAYERS];//vetores para armazenar as peças escolhidas pelo usuárioPar *piecesPlayer[NUM_PLAYERS];//jogadorint currentPlayer;int firstPlayer;//peçasint markedPieces[BOARD_ROW][BOARD_COLUMN];//estado do jogoint gameState;//coordenadas para a IA jogarint x, y;//--------------------------------------------------------------------------// Funções de manipulação de imagem//--------------------------------------------------------------------------//Carrega uma imagemunsigned char* loadImage(char *, IplImage **, int);//Realiza uma série de inicializaçõesvoid initInterface();//Executa o espelhamento vertical da imagemvoid verticalFlip(unsigned char *, int);//--------------------------------------------------------------------------// GLUT//--------------------------------------------------------------------------//Seta os parâmetros da GLUTvoid setGlut();//Função de callback - ajusta o tamanho da janelavoid reshape(int, int);//Função de callback - desenha a imagem na janelavoid display();//Desenha uma peça no tabuleirovoid drawPiece(Par *, int);//Desenha na tela qual o jogador que deve jogarvoid drawPlayerText();void glutBitmapString(void *, const char *);//Ajusta as coordenadas de centro de uma posição para imprimir a peça nesta posiçãoPar ajustPositionCoordinates(int, int);//Insere uma nova peça à lista de peçasPar *insertPar(Par, Par *);//Troca o jogadorvoid changePlayer();//Imprime os elementos de uma lista de peçasvoid printPieceList(Par *);//Função de callback - captura cliquesvoid mouse(int, int, int, int);//Vê se o jogo chegou ao fim com vitória, derrota ou empatevoid checkFinalGame(int);//Marca a jogada da IA no tabuleirovoid markIAMove(int, int, int);//Conta a quantidade de posições que ainda estão disponíveis para jogarint countZeros(int [BOARD_ROW][BOARD_COLUMN]);//Faz a chamada do minimax para o playerPCvoid activeMinimaxForPlayerPC();#endif