Algoritmo:

0) Interface recém aberta, sem imagens carregadas, botões mix, crop, put crop e zoom desabilitados

1) Carregar sourceImage e destImage
	1.1) Se sourceImage for carregado, habilitado botões de zoom do sourceImage e botão crop
	
	1.2) Se destImage for carregado, habilitado botões de zoom do destImage, botão mix e put crop permanecem desabilitados
	
	1.3) Fazer zoom nas imagens caso necessário.
	
	1.4) Selecionar área da sourceImage e apertar botão "Crop". croppedImage é gerado.
		1.4.1) Botões crop e zoom são desabilitados. Botão Put crop é habilitado.
		1.4.2) Testa se destImage é maior do que o crop da sourceImage. Se for maior segue, senão gera mensagem de erro e 
		volta para 0).
	
	1.5) Clicar no botão put crop e posicionar a croppedImage na destImage.		
		1.5.1) Capturar a posição do crop dentro da destImage e gerar a máscara, com o tamanho da destImage.
		1.5.2) Botão mix é habilitado.
	
	1.6) Clicar no mix.	 

2) Preparando Ax = b
	2.1) x são os valores finais dos pixels presente dentro da máscara, ou seja, a quantidade de pixels presentes dentro da 
	croppedImage. Os valores das incógnitas do vetor x correspondem aos gradientes dos pixels da máscara na imagem final.	
	
	2.2) A é uma matriz esparsa, ou seja, possui vários coeficientes iguais a zero. Cada linha da matriz é uma equação de poisson, 
	onde a equação possui coeficiente 4 para o pixel p em questão e coeficiente -1 para cada pixel q vizinho a p que esteja dentro
	da máscara. Se p está na posição (x,y), seus vizinhos serão os pixels q (x-1,y), (x+1,y), (x,y-1) e (x,y+1). 
	
	A: fx,y = 4p(x,y) - p(x-1,y) - p(x+1,y) - p(x,y-1) - p(x,y+1)
	(http://en.wikipedia.org/wiki/Discrete_Poisson_equation)
	
	// construindo A, a mesma para todos os 3 canais
	double A[][];
	initializeMatrixA(); //deixa todas as posições com zero
	
	int i = 0;
	for(int x = 0; x < mask.width; x++) {
		for(int y = 0; y < mask.height; y++) {
			if(mask[x][y] == 1) {
				A[i][i] = 4;
				if(mask[x-1][y] == 1 && (x-1) >= 0) //já testa o limite da imagem (não pode ser -1)
					A[i][i-1] += -1;
				if(mask[x+1][y] == 1 && (x+1) <= destImage.width)
					A[i][i+1] = -1;
				if(mask[x][y-1] == 1 && (y-1) >= 0) 
					A[i][i-crop.width] += -1;
				if(mask[x][y+1] == 1 && (y+1) <= destImage.height)
					A[i][i+crop.width] += -1;	
				i++;	
			}
		}
	}
	
	Obs.:
		* x e y são usados para varrer a imagem
		* i é usado para varrer as linhas da matriz A
		* crop.width é usado para atribuir -1 ao pixel certo, pois os vizinhos q do pixel p não necessariamente serão vizinhos de p na matriz
	
	2.3) b é um vetor onde cada posição corresponde ao gradiente do pixel p mais a soma dos gradientes dos pixels q vizinhos a p que
	NÃO estejam dentro da máscara e que são da destImage.
	"The vector b is the guiding gradient plus the sum of all non-masked neighbor pixels in the target image."
		2.3.1) Encontrar gradiente da cropImage e destImage (http://en.wikipedia.org/wiki/Image_gradient). Para cada canal fazer:
			2.3.1.1) Aplicar convolução com kernel sobel-x
			2.3.1.2) Aplicar convolução com kernel sobel-y
			2.3.1.3) Gradiente = ( Gx^2 + Gy^2 ) ^ (1/2), ou seja, o gradiente é a raiz da soma dos quadrados
			dos gradientes parciais em x e y --> gradientCropImage[][][] e gradientDestImage[][][]	
			
	// construindo b, um b para cada canal - versão mais rápida
	for(int channel = 0; channel < 3; channel++) {
		int i = 0;
		for(int x = 0; x < mask.width; x++) {
			for(int y = 0; y < mask.height; y++) {
				if(mask[x][y] == 1) {
					b[i][channel] = gradientCropImage[x][y][channel];	
					if(mask[x-1][y] == 0 && (x-1) >= 0) 
						b[i][channel] += gradientDestImage[x-1][y][channel];
					if(mask[x+1][y] == 0 && (x+1) <= destImage.width)
						b[i][channel] += gradientDestImage[x+1][y][channel];
					if(mask[x][y-1] == 0 && (y-1) >= 0) 
						b[i][channel] += gradientDestImage[x][y-1][channel];
					if(mask[x][y+1] == 0 && (y+1) <= destImage.height)
						b[i][channel] += gradientDestImage[x][y+1][channel];	
					i++;	
				}	
			}
		}
	}
	
	ou
	
	int i = 0;
	for(int x = 0; x < mask.width; x++) {
		for(int y = 0; y < mask.height; y++) {
			if(mask[x][y] == 1) {
				b[i][0] = gradientCropImage[x][y][0];	
				b[i][1] = gradientCropImage[x][y][1];	
				b[i][2] = gradientCropImage[x][y][2];	
				if(mask[x-1][y] == 0 && (x-1) >= 0) {
					b[i][0] += gradientDestImage[x-1][y][0];
					b[i][1] += gradientDestImage[x-1][y][1];
					b[i][2] += gradientDestImage[x-1][y][2];
				}
				if(mask[x+1][y] == 0 && (x+1) <= destImage.width) {
					b[i][0] += gradientDestImage[x+1][y][0];
					b[i][1] += gradientDestImage[x+1][y][1];
					b[i][2] += gradientDestImage[x+1][y][2];
				}
				if(mask[x][y-1] == 0 && (y-1) >= 0) {
					b[i][0] += gradientDestImage[x][y-1][0];
					b[i][1] += gradientDestImage[x][y-1][1];
					b[i][2] += gradientDestImage[x][y-1][2];
				}
				if(mask[x][y+1] == 0 && (y+1) <= destImage.height) {
					b[i][0] += gradientDestImage[x][y+1][0];	
					b[i][1] += gradientDestImage[x][y+1][1];	
					b[i][2] += gradientDestImage[x][y+1][2];	
				}
				i++;	
			}	
		}
	}
			
3) Resolver equações de poisson
	3.1) Utilizar algoritmo otimizado para solucionar sistemas lineares.
	3.2) Resolver A * x = b para cada um dos canais.
	3.3) x será o resultado final. Unir os 3 canais para formar a imagem final.
		
    if mask(x,y) is 0:
        final(x,y) = target(x,y)
    else:
        final(x,y) = 0
        for each neighbor (nx,ny) in (x-1,y), (x+1,y), (x,y-1), (x,y+1):
            final(x,y) += source(x,y) - source(nx,ny)
            if mask(nx,ny) is 0:
                final(x,y) += target(nx,ny)
            else:
                final(x,y) += final(nx,ny)
               

    
                         
                
   
        
  