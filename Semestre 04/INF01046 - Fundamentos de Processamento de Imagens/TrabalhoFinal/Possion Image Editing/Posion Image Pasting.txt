---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
Algoritmo:

1) Carregar sourceImage
	1.1) Selecionar área da sourceImage, nosso croppedImage. 
	1.2) Também criar máscara. Área selecionada em branco, resto preto.	
	
2) Carregar destImage
	2.1) Posicionar croppedImage na destImage
		2.1.1) Capturar posição em que a croppedImage está posicionada.
	2.2) Clicar no botão mix
	2.3) Construir imagem final

	if mask(x,y) is 0:
		final(x,y) = target(x,y)
	else:
		final(x,y) = 0
		for each neighbor (nx,ny) in (x-1,y), (x+1,y), (x,y-1), (x,y+1):
			final(x,y) += source(x,y) - source(nx,ny)
			if mask(nx,ny) is 0:
				final(x,y) += target(nx,ny)
			else:
				final(x,y) += final(nx,ny)
				
3) Resolver equações de poisson
	3.1) Encontrar gradiente da sourceImage e destImage (http://en.wikipedia.org/wiki/Image_gradient)
		3.1.1) Criar duas cópias da imagem.
		3.1.2) Aplicar em uma das cópia convolução com kernel sobel-x
		3.1.3) Aplicar em uma das cópia convolução com kernel sobel-y
		3.1.4) Gradiente = ( Gx^2 + Gy^2 ) ^ (1/2), ou seja, o gradiente é a raiz da soma dos quadrados 
		dos gradientes parciais em x e y
		
		Gradiente sendo usado: http://yuwing.kaist.ac.kr/courses/CS770/pdf/06-GradientImageManipulation.pdf - página 5
		Como encontrar o gradiente: http://en.wikipedia.org/wiki/Sobel_operator
	
	3.2) Resolver Ax = b.
		3.2.1)  x: tamanho igual ao número de pixels da destImage. Contém todos os pixels da imagem final
		
				b: tamanho igual ao número de pixels da destImage. Cada posição é o gradiente 
				daquele pixel + os pixels vizinhos que não estão na máscara
				
				A: fx,y = 4px,y - px-1,y - px+1,y - px,y-1 - px,y+1
				(http://en.wikipedia.org/wiki/Discrete_Poisson_equation)
	
		3.2.2) Com o sistema resolvido o resultado estará no vetor x, que será a imagem final.
	
		"However, all masked pixels (where the mask is nonzero) depend on each other for their final value.  We have to compute 
		everything simultaneously, which can be done by solving the matrix equation Ax = b.  The size of both vectors x and b 
		is the number of pixels in the target image.  The vector x contains all pixels in the final image (what we are solving 
		for).  The vector b is the guiding gradient plus the sum of all non-masked neighbor pixels in the target image.  The 
		non-masked neighbor pixels define the value of the pixels at the boundary of the mask, which are blended across the 
		mask area.  The guiding gradient defines the second derivative of the final pixels in the mask area, and helps to 
		"shape" what is blended in the mask area.  The matrix A is a sparse matrix with a 4 for each pixel and a -1 for each 
		neighbor pixel under the mask, and computes the gradient of the masked pixels in the final image.  To get the final image, 
		simply solve the equation for x.  If the guiding gradient is zero, we are just solving a Laplace equation and the values 
		at the mask boundary are blended smoothly across"				
		(http://www.cs.brown.edu/courses/csci1950-g/results/proj2/edwallac/)		
				
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------				

Ajuda:

Resolver sistemas lineares: http://www.csee.umbc.edu/~squire/cs455_l3.html (código em java, mas tem que ver se resolve sistemas de 
equações lineares com mais de 3 incógnitas)

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

Entendendo Poisson image editing (http://www.cs.brown.edu/courses/csci1950-g/asgn/proj2/resources/PoissonImageEditing.pdf)
2) Poisson solution to guided interpolation: Guided Interpolation & Discrete Poisson solver

S: sub-conjunto fechado do R² que define a imagem
f*: função da imagem definida na área S menos o interior da área definida por Ohm
Ohm: sub-conjunto fechado em S que define a área de interesse
dOhm: borda da imagem definida na área de Ohm
f: função desconhecida da imagem presente no sub-cojunto Ohm
v: gradiente da imagem presente no sub-conjunto Ohm, de função f
g: função da imagem de origem
p: pixel em S
fp: resultado de f para o pixel p
Np: conjunto dos quatro pixels vizinhos a um pixel p, todos os pixels pertencentes a S

Objetivo: calcular os valores de f para p pertencente a Ohm, ou seja,
calcular fp, onde os p's estão em Ohm (imagem colada na imagem de destino).

Linear Equation Solver
http://alumnus.caltech.edu/~chamness/equation/equation.html

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------






























